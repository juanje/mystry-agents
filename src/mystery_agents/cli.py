"""CLI entry point for mystery party game generator."""

import sys
from pathlib import Path

import click

from mystery_agents.graph.workflow import create_workflow
from mystery_agents.models.state import GameConfig, GameState, MetaInfo, PlayerConfig
from mystery_agents.utils.constants import (
    CLUES_DIR,
    DEFAULT_OUTPUT_DIR,
    DEFAULT_RECURSION_LIMIT,
    GAME_ID_LENGTH,
    HOST_DIR,
    PLAYERS_DIR,
)


@click.command()
@click.option(
    "--output-dir",
    default=DEFAULT_OUTPUT_DIR,
    help="Output directory for generated games",
    type=click.Path(path_type=Path),
)
@click.option(
    "--dry-run",
    is_flag=True,
    default=False,
    help="Use mock data instead of calling LLMs (generates PDFs and files but skips API calls)",
)
@click.option(
    "--debug",
    is_flag=True,
    default=False,
    help="Enable debug mode to log model responses (useful for troubleshooting)",
)
@click.option(
    "--no-images",
    is_flag=True,
    default=False,
    help="Skip character portrait image generation (images are generated by default)",
)
@click.option(
    "--config",
    type=click.Path(exists=True, path_type=Path),
    default=None,
    help="Load configuration from YAML file (skips interactive wizard)",
)
@click.option(
    "--keep-work-dir",
    is_flag=True,
    default=False,
    help="Keep intermediate working directory with markdown files for inspection",
)
def generate(
    output_dir: Path,
    dry_run: bool,
    debug: bool,
    no_images: bool,
    config: Path | None,
    keep_work_dir: bool,
) -> None:
    """
    Generate a mystery party game.

    This command launches the mystery party game generator, which will:
    1. Collect your preferences (theme, tone, players, etc.)
    2. Generate a complete mystery with characters, clues, and plot
    3. Create all materials needed to run the game
    4. Package everything into a ready-to-use ZIP file
    """
    click.echo("\n" + "=" * 60)
    click.echo("       MYSTERY PARTY GAME GENERATOR")
    click.echo("=" * 60 + "\n")

    # Image generation is enabled by default (unless --no-images flag is used)
    generate_images = not no_images

    # Create output directory if it doesn't exist
    output_dir.mkdir(parents=True, exist_ok=True)

    initial_state = GameState(
        meta=MetaInfo(),
        config=GameConfig(
            players=PlayerConfig(total=6),
            generate_images=generate_images,
            dry_run=dry_run,
            debug_model=debug,
            duration_minutes=90,
            config_file=str(config) if config else None,
            keep_work_dir=keep_work_dir,
        ),
    )

    # Create and run workflow
    try:
        click.echo("Initializing workflow...\n")
        workflow = create_workflow()

        workflow_config = {"recursion_limit": DEFAULT_RECURSION_LIMIT}
        all_states = []
        for output in workflow.stream(initial_state, config=workflow_config):
            for node_name, state in output.items():
                all_states.append((node_name, state))

        # Check if we got any states
        if not all_states:
            click.echo("\nâŒ Error: Workflow did not produce output", err=True)
            sys.exit(1)

        final_node_name, final_state = all_states[-1]

        if not isinstance(final_state, dict):
            click.echo("\nâŒ Error: Unexpected state format", err=True)
            sys.exit(1)

        # Check world validation first (V2)
        world_validation = final_state.get("world_validation")
        if world_validation and not world_validation.is_coherent:
            click.echo(
                "\nâŒ Game generation failed: World validation failed after max retries", err=True
            )
            click.echo("\nWorld coherence issues:")
            for issue in world_validation.issues:
                click.echo(f"  - {issue}")
            if world_validation.suggestions:
                click.echo("\nSuggestions for improvement:")
                for suggestion in world_validation.suggestions:
                    click.echo(f"  - {suggestion}")
            sys.exit(1)

        # Check full game validation (V1)
        validation = final_state.get("validation")
        if validation and not validation.is_consistent:
            click.echo("\nâŒ Game generation failed validation", err=True)
            click.echo("\nValidation issues:")
            for issue in validation.issues:
                click.echo(f"  - {issue.type}: {issue.description}")
            click.echo("\nSuggested fixes:")
            for fix in validation.suggested_fixes:
                click.echo(f"  - {fix}")
            sys.exit(1)

        # Success!
        click.echo("\n" + "=" * 60)
        click.echo("âœ“ GAME GENERATED SUCCESSFULLY!")
        click.echo("=" * 60 + "\n")

        packaging = final_state.get("packaging")
        if packaging:
            click.echo(packaging.index_summary)

        meta = final_state.get("meta")
        if not meta:
            click.echo("\nâŒ Error: Missing meta information", err=True)
            sys.exit(1)
        game_id = meta.id[:GAME_ID_LENGTH]
        from mystery_agents.utils.constants import GAME_DIR_PREFIX, ZIP_FILE_PREFIX

        zip_path = output_dir / f"{ZIP_FILE_PREFIX}{game_id}.zip"

        click.echo("\nðŸ“¦ Your game package is ready:")
        click.echo(f"   {zip_path}")
        click.echo("\nðŸ“ Unpacked files are in:")
        click.echo(f"   {output_dir / f'{GAME_DIR_PREFIX}{game_id}'}")

        click.echo("\n" + "=" * 60)
        click.echo("NEXT STEPS:")
        click.echo("=" * 60)
        click.echo("1. Extract the ZIP file")
        from mystery_agents.utils.constants import HOST_GUIDE_FILENAME

        click.echo(f"2. Read the host guide in /{HOST_DIR}/{HOST_GUIDE_FILENAME}")
        click.echo(f"3. Send each player their package from /{PLAYERS_DIR}/")
        click.echo(f"4. Print or prepare the clues from /{CLUES_DIR}/")
        click.echo("5. Host an amazing mystery party!")
        click.echo("\nHave fun! ðŸŽ­\n")

    except KeyboardInterrupt:
        click.echo("\n\nâš ï¸  Generation cancelled by user (Ctrl-C)", err=True)
        sys.exit(130)
    except click.exceptions.Abort:
        click.echo("\n\nâš ï¸  Configuration cancelled by user", err=True)
        click.echo("   No game was generated.", err=True)
        sys.exit(130)
    except Exception as e:
        # Check if it's an API key error (common with Google Gemini)
        error_message = str(e).lower()
        if "api key" in error_message or "api_key_invalid" in error_message:
            click.echo("\n\nâŒ API Key Error", err=True)
            click.echo("=" * 60, err=True)
            click.echo("\nThe Google Gemini API key is missing or invalid.", err=True)
            click.echo("\nTo fix this, set your API key as an environment variable:", err=True)
            click.echo("\n  export GOOGLE_API_KEY='your-api-key-here'", err=True)
            click.echo("\nTo get an API key:", err=True)
            click.echo("  1. Visit: https://aistudio.google.com/apikey", err=True)
            click.echo("  2. Create a new API key", err=True)
            click.echo("  3. Set it as an environment variable (see above)", err=True)
            click.echo("\nðŸ’¡ Tip: Use --dry-run flag to test without API calls:", err=True)
            click.echo("  mystery-agents --dry-run", err=True)
            click.echo("\n" + "=" * 60, err=True)
            sys.exit(1)

        # Generic error handling for other exceptions
        click.echo(f"\n\nâŒ Error during generation: {e}", err=True)
        import traceback

        traceback.print_exc()
        sys.exit(1)


@click.group()
def cli() -> None:
    """Mystery Party Game Generator - Create complete mystery games with AI."""
    pass


cli.add_command(generate)


if __name__ == "__main__":
    generate()
