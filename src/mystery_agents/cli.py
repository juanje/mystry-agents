"""CLI entry point for mystery party game generator."""

import sys
from pathlib import Path

import click

# Lightweight imports only - heavy imports moved inside functions
from mystery_agents.utils.constants import DEFAULT_OUTPUT_DIR


@click.command()
@click.argument(
    "game_config_file",
    type=click.Path(path_type=Path),
    required=False,
    default=None,
    metavar="GAME_CONFIG_FILE",
)
@click.option(
    "--output-dir",
    default=DEFAULT_OUTPUT_DIR,
    help="Output directory for generated games",
    type=click.Path(path_type=Path),
)
@click.option(
    "--dry-run",
    is_flag=True,
    default=False,
    help="Use mock data instead of calling LLMs (generates PDFs and files but skips API calls)",
)
@click.option(
    "--debug",
    is_flag=True,
    default=False,
    help="Enable debug mode to log model responses (useful for troubleshooting)",
)
@click.option(
    "--no-images",
    is_flag=True,
    default=False,
    help="Skip character portrait image generation (images are generated by default)",
)
@click.option(
    "--keep-work-dir",
    is_flag=True,
    default=False,
    help="Keep intermediate working directory with markdown files for inspection",
)
@click.option(
    "-v",
    "--verbose",
    count=True,
    help="Increase verbosity (-v for INFO logs, -vv for DEBUG logs)",
)
@click.option(
    "--quiet",
    is_flag=True,
    default=False,
    help="Minimal output (only start/end/errors, mutually exclusive with -v)",
)
@click.option(
    "--log-file",
    type=click.Path(path_type=Path),
    default=None,
    help="Write logs to specified file",
)
def generate(
    game_config_file: Path | None,
    output_dir: Path,
    dry_run: bool,
    debug: bool,
    no_images: bool,
    keep_work_dir: bool,
    verbose: int,
    quiet: bool,
    log_file: Path | None,
) -> None:
    """
    Generate a mystery party game from a YAML configuration file.

    GAME_CONFIG_FILE: Path to YAML game configuration file (defaults to game.yml if it exists)

    The generator will:
    1. Load game configuration from YAML file
    2. Generate a complete mystery with characters, clues, and plot
    3. Create all materials needed to run the game
    4. Package everything into a ready-to-use ZIP file

    Examples:

    \b
    $ mystery-agents                      # Uses game.yml if it exists
    $ mystery-agents my-game.yml          # Uses specific config file
    $ mystery-agents --dry-run            # Test without API calls (uses game.yml)
    """
    # Validate mutually exclusive flags
    if quiet and verbose > 0:
        click.echo("âŒ Error: --quiet and -v/--verbose are mutually exclusive", err=True)
        sys.exit(1)

    # Load environment variables from .env file (if it exists)
    # Only load when actually running, not when showing help
    from dotenv import load_dotenv

    load_dotenv()

    # Setup logging system
    from mystery_agents.utils.logging_config import setup_logging

    setup_logging(verbosity=verbose, quiet=quiet, log_file=str(log_file) if log_file else None)

    click.echo("\n" + "=" * 60)
    click.echo("       MYSTERY PARTY GAME GENERATOR")
    click.echo("=" * 60 + "\n")

    # Resolve config file path
    if game_config_file is None:
        # Try default file name
        default_config = Path("game.yml")
        if default_config.exists():
            game_config_file = default_config
        else:
            click.echo("âŒ Error: No configuration file found", err=True)
            click.echo("\nPlease provide a configuration file:", err=True)
            click.echo("  mystery-agents my-config.yml", err=True)
            click.echo("\nOr create a default game.yml file:", err=True)
            click.echo("  cp game.example.yml game.yml", err=True)
            click.echo("  # Edit game.yml with your preferences", err=True)
            click.echo("\nFor a quick test with example config:", err=True)
            click.echo("  mystery-agents game.example.yml --dry-run", err=True)
            sys.exit(1)

    # Verify config file exists
    if not game_config_file.exists():
        click.echo(f"âŒ Error: Configuration file not found: {game_config_file}", err=True)
        sys.exit(1)

    # Image generation is enabled by default (unless --no-images flag is used)
    generate_images = not no_images

    # Create output directory if it doesn't exist
    output_dir.mkdir(parents=True, exist_ok=True)

    # Import heavy dependencies only when actually running (not for --help)
    from mystery_agents.graph.workflow import create_workflow
    from mystery_agents.models.state import GameConfig, GameState, MetaInfo, PlayerConfig
    from mystery_agents.utils.constants import DEFAULT_RECURSION_LIMIT, GAME_ID_LENGTH

    initial_state = GameState(
        meta=MetaInfo(),
        config=GameConfig(
            players=PlayerConfig(total=6),
            generate_images=generate_images,
            dry_run=dry_run,
            debug_model=debug,
            duration_minutes=90,
            config_file=str(game_config_file),
            keep_work_dir=keep_work_dir,
            verbosity=verbose,
            quiet_mode=quiet,
            log_file=str(log_file) if log_file else None,
        ),
    )

    # Create and run workflow
    try:
        click.echo("Initializing workflow...\n")
        workflow = create_workflow()

        workflow_config = {"recursion_limit": DEFAULT_RECURSION_LIMIT}
        all_states = []
        for output in workflow.stream(initial_state, config=workflow_config):
            for node_name, state in output.items():
                all_states.append((node_name, state))

        # Check if we got any states
        if not all_states:
            click.echo("\nâŒ Error: Workflow did not produce output", err=True)
            sys.exit(1)

        final_node_name, final_state = all_states[-1]

        if not isinstance(final_state, dict):
            click.echo("\nâŒ Error: Unexpected state format", err=True)
            sys.exit(1)

        # Check world validation first (V2)
        world_validation = final_state.get("world_validation")
        if world_validation and not world_validation.is_coherent:
            click.echo(
                "\nâŒ Game generation failed: World validation failed after max retries", err=True
            )
            click.echo("\nWorld coherence issues:")
            for issue in world_validation.issues:
                click.echo(f"  - {issue}")
            if world_validation.suggestions:
                click.echo("\nSuggestions for improvement:")
                for suggestion in world_validation.suggestions:
                    click.echo(f"  - {suggestion}")
            sys.exit(1)

        # Check full game validation (V1)
        validation = final_state.get("validation")
        if validation and not validation.is_consistent:
            click.echo("\nâŒ Game generation failed validation", err=True)
            click.echo("\nValidation issues:")
            for issue in validation.issues:
                click.echo(f"  - {issue.type}: {issue.description}")
            click.echo("\nSuggested fixes:")
            for fix in validation.suggested_fixes:
                click.echo(f"  - {fix}")
            sys.exit(1)

        # Success! Show concise summary in all modes
        meta = final_state.get("meta")
        if not meta:
            click.echo("\nâŒ Error: Missing meta information", err=True)
            sys.exit(1)
        game_id = meta.id[:GAME_ID_LENGTH]
        from mystery_agents.utils.constants import GAME_DIR_PREFIX, ZIP_FILE_PREFIX

        zip_path = output_dir / f"{ZIP_FILE_PREFIX}{game_id}.zip"

        # Show concise summary in all modes (default, quiet, and verbose)
        click.echo("\n" + "=" * 60)
        click.echo("âœ“ GAME GENERATED SUCCESSFULLY!")
        click.echo("=" * 60 + "\n")
        click.echo(f"ðŸ“¦ Game package: {zip_path}")
        click.echo(f"ðŸ“ Files directory: {output_dir / f'{GAME_DIR_PREFIX}{game_id}'}\n")

    except KeyboardInterrupt:
        click.echo("\n\nâš ï¸  Generation cancelled by user (Ctrl-C)", err=True)
        sys.exit(130)
    except click.exceptions.Abort:
        click.echo("\n\nâš ï¸  Configuration cancelled by user", err=True)
        click.echo("   No game was generated.", err=True)
        sys.exit(130)
    except Exception as e:
        # Check if it's an API key error (common with Google Gemini)
        error_message = str(e).lower()
        if "api key" in error_message or "api_key_invalid" in error_message:
            click.echo("\n\nâŒ API Key Error", err=True)
            click.echo("=" * 60, err=True)
            click.echo("\nThe Google Gemini API key is missing or invalid.", err=True)
            click.echo("\nTo fix this, choose one of these options:", err=True)
            click.echo("\n  Option 1: Create a .env file (recommended)", err=True)
            click.echo("    1. Copy env.example to .env", err=True)
            click.echo("    2. Edit .env and add your API key", err=True)
            click.echo("\n  Option 2: Set environment variable", err=True)
            click.echo("    export GOOGLE_API_KEY='your-api-key-here'", err=True)
            click.echo("\nTo get an API key:", err=True)
            click.echo("  1. Visit: https://aistudio.google.com/apikey", err=True)
            click.echo("  2. Create a new API key", err=True)
            click.echo("  3. Configure it using one of the options above", err=True)
            click.echo("\nðŸ’¡ Tip: Use --dry-run flag to test without API calls:", err=True)
            click.echo("  mystery-agents game.yml --dry-run", err=True)
            click.echo("\n" + "=" * 60, err=True)
            sys.exit(1)

        # Generic error handling for other exceptions
        click.echo(f"\n\nâŒ Error during generation: {e}", err=True)
        import traceback

        traceback.print_exc()
        sys.exit(1)


@click.group()
def cli() -> None:
    """Mystery Party Game Generator - Create complete mystery games with AI."""
    pass


cli.add_command(generate)


if __name__ == "__main__":
    generate()
